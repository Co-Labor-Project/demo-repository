"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Circle: () => Circle,
  Container: () => Container,
  ContainerContext: () => ContainerContext,
  Ellipse: () => Ellipse,
  EventTargetContext: () => EventTargetContext,
  GroundOverlay: () => GroundOverlay,
  InfoWindow: () => InfoWindow,
  Listener: () => Listener,
  LoadNavermapsScript: () => LoadNavermapsScript,
  Marker: () => Marker,
  NaverMap: () => NaverMap,
  NaverMapContext: () => NaverMapContext,
  NavermapsProvider: () => NavermapsProvider,
  Overlay: () => Overlay,
  Polygon: () => Polygon,
  Polyline: () => Polyline,
  Rectangle: () => Rectangle,
  RenderAfterNavermapsLoaded: () => RenderAfterNavermapsLoaded,
  loadNavermapsScript: () => loadNavermapsScript,
  useContainerContext: () => useContainerContext,
  useEventTarget: () => useEventTarget,
  useListener: () => useListener,
  useMap: () => useMap,
  useNavermaps: () => useNavermaps
});
module.exports = __toCommonJS(src_exports);

// src/contexts/client-options.ts
var import_react = require("react");
var ClientOptionsContext = (0, import_react.createContext)({});
var useClientOptions = () => (0, import_react.useContext)(ClientOptionsContext);

// src/provider.tsx
var import_jsx_runtime = require("react/jsx-runtime");
function NavermapsProvider({
  children,
  ...clientOptions
}) {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ClientOptionsContext.Provider, {
    value: clientOptions,
    children
  });
}

// src/naver-map.tsx
var import_lodash2 = __toESM(require("lodash.pick"));
var import_lodash3 = __toESM(require("lodash.upperfirst"));
var import_react9 = require("react");

// src/contexts/container.ts
var import_react2 = require("react");
var ContainerContext = (0, import_react2.createContext)({ element: null });
var useContainerContext = () => (0, import_react2.useContext)(ContainerContext);

// src/contexts/event-target.ts
var import_react3 = require("react");
var EventTargetContext = (0, import_react3.createContext)(void 0);
var useEventTarget = () => (0, import_react3.useContext)(EventTargetContext);

// src/contexts/naver-map.ts
var import_react4 = require("react");
var NaverMapContext = (0, import_react4.createContext)(void 0);
var useMap = () => (0, import_react4.useContext)(NaverMapContext);

// src/helpers/event.tsx
var import_camelcase = __toESM(require("camelcase"));
var import_lodash = __toESM(require("lodash.pick"));
var import_react6 = require("react");

// src/listener.tsx
var import_react5 = require("react");
function useListener(target, type, listener) {
  (0, import_react5.useEffect)(() => {
    const _listener = (...args) => listener(...args, target);
    const mapEventListener = naver.maps.Event.addListener(target, type, _listener);
    return () => {
      naver.maps.Event.removeListener(mapEventListener);
    };
  }, [target, type, listener]);
}
var Listener = (props) => {
  const {
    target: propTarget,
    type,
    listener
  } = props;
  const contextTarget = useEventTarget();
  const target = propTarget || contextTarget;
  if (!target) {
    throw new Error("react-naver-maps: No Target to add listener");
  }
  useListener(target, type, listener);
  return null;
};

// src/helpers/event.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
function HandleEvents(props) {
  const { events: events10, listeners: _listeners } = props;
  const eventMap = (0, import_react6.useMemo)(() => createEventMap(events10), events10);
  const listeners = (0, import_lodash.default)(_listeners, Object.keys(eventMap));
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {
    children: Object.keys(listeners).map((key) => {
      const eventName = eventMap[key];
      const listener = listeners[key];
      return listener ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Listener, {
        type: eventName,
        listener
      }, key) : null;
    })
  });
}
function createEventMap(events10) {
  return events10.reduce((acc, eventName) => {
    const key = (0, import_camelcase.default)(`on_${eventName}`);
    return {
      [key]: eventName,
      ...acc
    };
  }, {});
}

// src/hooks/use-previous.ts
var import_react7 = require("react");
function usePrevious(state, deps) {
  const ref = (0, import_react7.useRef)();
  (0, import_react7.useEffect)(() => {
    ref.current = state;
  }, deps);
  return ref.current;
}

// src/use-navermaps.ts
var import_suspend_react = require("suspend-react");

// src/load-navermaps-script.tsx
var import_react8 = require("react");

// src/utils/load-script.ts
var import_load_script = __toESM(require("load-script"));
function loadScript(src) {
  return new Promise((resolve, reject) => {
    (0, import_load_script.default)(src, (err, script) => {
      if (err)
        reject(err);
      else
        resolve(script);
    });
  });
}

// src/load-navermaps-script.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
function loadNavermapsScript(options) {
  const url = makeUrl(options);
  const promise = loadScript(url).then(() => {
    const navermaps = window.naver.maps;
    if (navermaps.jsContentLoaded) {
      return navermaps;
    }
    return new Promise((resolve) => {
      navermaps.onJSContentLoaded = () => {
        resolve(navermaps);
      };
    });
  });
  return promise;
}
function makeUrl(options) {
  const submodules = options.submodules;
  const clientIdQuery = "ncpClientId" in options ? `ncpClientId=${options.ncpClientId}` : "govClientId" in options ? `govClientId=${options.govClientId}` : "finClientId" in options ? `finClientId=${options.finClientId}` : void 0;
  if (!clientIdQuery) {
    throw new Error("react-naver-maps: ncpClientId, govClientId or finClientId is required");
  }
  let url = `https://oapi.map.naver.com/openapi/v3/maps.js?${clientIdQuery}`;
  if (submodules) {
    url += `&submodules=${submodules.join(",")}`;
  }
  return url;
}
function LoadNavermapsScript({
  children: Children,
  ...options
}) {
  const [navermaps, setNavermaps] = (0, import_react8.useState)();
  (0, import_react8.useEffect)(() => {
    loadNavermapsScript(options).then((maps) => {
      setNavermaps(maps);
    });
  }, []);
  return navermaps && Children ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Children, {}) : null;
}

// src/use-navermaps.ts
async function load(options) {
  var _a;
  if (typeof window !== "undefined" && ((_a = window.naver) == null ? void 0 : _a.maps)) {
    return window.naver.maps;
  }
  if (!options) {
    throw new Error("react-naver-maps: set options with `useNavermaps.config`");
  }
  return await loadNavermapsScript(options);
}
function useNavermaps() {
  var _a;
  if (typeof window === "undefined") {
    throw new Error("react-naver-maps: browser");
  }
  if ((_a = window.naver) == null ? void 0 : _a.maps) {
    return window.naver.maps;
  }
  const options = useClientOptions();
  return (0, import_suspend_react.suspend)(load, [options, "react-naver-maps/loadClient"]);
}

// src/naver-map.tsx
var import_jsx_runtime4 = require("react/jsx-runtime");
var basicMapOptionKeys = [
  "background",
  "baseTileOpacity",
  "disableDoubleClickZoom",
  "disableDoubleTapZoom",
  "disableKineticPan",
  "disableTwoFingerTapZoom",
  "draggable",
  "keyboardShortcuts",
  "logoControl",
  "logoControlOptions",
  "mapDataControl",
  "mapDataControlOptions",
  "mapTypeControl",
  "mapTypeControlOptions",
  "mapTypes",
  "maxBounds",
  "maxZoom",
  "minZoom",
  "padding",
  "pinchZoom",
  "resizeOrigin",
  "scaleControl",
  "scaleControlOptions",
  "scrollWheel",
  "overlayZoomEffect",
  "tileSpare",
  "tileTransition",
  "zoomControl",
  "zoomControlOptions",
  "zoomOrigin",
  "blankTileImage"
];
var kvoKeys = [
  "mapTypeId",
  "size",
  "bounds",
  "center",
  "zoom",
  "centerPoint"
];
var kvoEvents = [
  ...kvoKeys.map((key) => `${key}_changed`),
  "mapType_changed"
];
var uiEvents = [
  "mousedown",
  "mouseup",
  "click",
  "dblclick",
  "rightclick",
  "mouseover",
  "mouseout",
  "mousemove",
  "dragstart",
  "drag",
  "dragend",
  "touchstart",
  "touchmove",
  "touchend",
  "pinchstart",
  "pinch",
  "pinchend",
  "tap",
  "longtap",
  "twofingertap",
  "doubletap"
];
var mapOnlyEvents = [
  "addLayer",
  "idle",
  "init",
  "keydown",
  "keyup",
  "panning",
  "projection_changed",
  "removeLayer",
  "resize",
  "tilesloaded",
  "zooming"
];
var events = [...uiEvents, ...kvoEvents, ...mapOnlyEvents];
var defaultOptionKeyMap = {
  mapTypeId: "defaultMapTypeId",
  size: "defaultSize",
  bounds: "defaultBounds",
  center: "defaultCenter",
  zoom: "defaultZoom",
  centerPoint: "defaultCenterPoint"
};
var NaverMap = (0, import_react9.forwardRef)(function NaverMap2(props, ref) {
  const navermaps = useNavermaps();
  const { element: mapDiv } = useContainerContext();
  const [nmap, setNmap] = (0, import_react9.useState)();
  const nmapRef = (0, import_react9.useRef)();
  (0, import_react9.useLayoutEffect)(() => {
    if (!mapDiv) {
      throw new Error("react-naver-maps: MapDiv is not found. Did you correctly wrap with `MapDiv`?");
    }
    const basicMapOptions = (0, import_lodash2.default)(props, basicMapOptionKeys);
    const kvos = kvoKeys.reduce((acc, key) => {
      if (props[defaultOptionKeyMap[key]]) {
        return {
          ...acc,
          [key]: props[defaultOptionKeyMap[key]]
        };
      }
      if (props[key]) {
        return {
          ...acc,
          [key]: props[key]
        };
      }
      return acc;
    }, {});
    const _nmap = new navermaps.Map(mapDiv, { ...basicMapOptions, ...kvos });
    setNmap(_nmap);
    nmapRef.current = _nmap;
    return () => {
      _nmap.destroy();
    };
  }, []);
  const uncontrolledOmittedProps = Object.keys(props).reduce((acc, key) => {
    if (key in defaultOptionKeyMap && props[defaultOptionKeyMap[key]]) {
      return acc;
    }
    return {
      ...acc,
      [key]: props[key]
    };
  }, {});
  (0, import_react9.useImperativeHandle)(ref, () => nmapRef.current);
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, {
    children: nmap && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(NaverMapCore, {
      ...uncontrolledOmittedProps,
      nmap
    })
  });
});
function NaverMapCore({ nmap, children, ...mapProps }) {
  const basicMapOptions = (0, import_lodash2.default)(mapProps, basicMapOptionKeys);
  const {
    mapTypeId,
    size,
    bounds,
    center,
    centerPoint,
    zoom
  } = mapProps;
  const prevKVOs = usePrevious({
    mapTypeId,
    size,
    bounds,
    center,
    centerPoint,
    zoom
  }, [
    mapTypeId,
    size,
    bounds,
    center,
    centerPoint,
    zoom
  ]);
  function getDirtyKVOs(keys) {
    return keys.reduce((acc, key) => {
      const currentValue = nmap[`get${(0, import_lodash3.default)(key)}`]();
      const propValue = mapProps[key];
      if (!propValue || prevKVOs && prevKVOs[key] === propValue) {
        return acc;
      }
      const isEqual = typeof currentValue.equals === "function" ? currentValue.equals(propValue) : currentValue === propValue;
      if (isEqual) {
        return acc;
      }
      return {
        ...acc,
        [key]: propValue
      };
    }, {});
  }
  (0, import_react9.useLayoutEffect)(() => {
    nmap.setOptions(basicMapOptions);
  }, [Object.values(basicMapOptions)]);
  (0, import_react9.useLayoutEffect)(() => {
    const updated = getDirtyKVOs(["size"]).size;
    if (updated) {
      nmap.setSize(updated);
    }
  }, [size]);
  (0, import_react9.useLayoutEffect)(() => {
    const updated = getDirtyKVOs(["mapTypeId"]).mapTypeId;
    if (updated) {
      nmap.setMapTypeId(updated);
    }
  }, [mapTypeId]);
  (0, import_react9.useLayoutEffect)(() => {
    const dirties = getDirtyKVOs(["bounds", "center", "centerPoint", "zoom"]);
    if (dirties.bounds) {
      nmap.fitBounds(dirties.bounds);
      return;
    }
    if (dirties.center && dirties.zoom) {
      nmap.morph(dirties.center, dirties.zoom);
      return;
    }
    if (dirties.centerPoint) {
      nmap.setCenterPoint(dirties.centerPoint);
    }
    if (dirties.center) {
      nmap.panTo(dirties.center, {});
    }
    if (dirties.zoom) {
      nmap.setZoom(dirties.zoom);
    }
  }, [bounds, center, centerPoint, zoom]);
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(NaverMapContext.Provider, {
    value: nmap,
    children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(EventTargetContext.Provider, {
      value: nmap,
      children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, {
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(HandleEvents, {
            events,
            listeners: mapProps
          }),
          children
        ]
      })
    })
  });
}

// src/container.tsx
var import_react10 = require("react");
var import_jsx_runtime5 = require("react/jsx-runtime");
var innerDefaultStyle = { top: 0, left: 0, width: "100%", height: "100%", position: "absolute", zIndex: 0 };
function Container({ children, fallback, innerStyle = innerDefaultStyle, ...restProps }) {
  const ref = (0, import_react10.useRef)(null);
  const [isMounted, setIsMounted] = (0, import_react10.useState)(false);
  (0, import_react10.useEffect)(() => {
    setIsMounted(true);
  }, []);
  const containerContext = (0, import_react10.useMemo)(() => ({ element: ref.current }), [ref.current]);
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", {
    ...restProps,
    style: { position: "relative", ...restProps.style },
    children: [
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", {
        ref,
        style: innerStyle
      }, "mapdiv"),
      isMounted && ref.current ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(ContainerContext.Provider, {
        value: containerContext,
        children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react10.Suspense, {
          fallback: null,
          children: typeof children === "function" ? (0, import_react10.createElement)(children) : children
        })
      }) : fallback
    ]
  });
}

// src/overlays/circle.tsx
var import_lodash4 = __toESM(require("lodash.pick"));
var import_react12 = require("react");

// src/overlay.tsx
var import_react11 = require("react");
var import_jsx_runtime6 = require("react/jsx-runtime");
function Overlay(props) {
  const { element, children, autoMount = true } = props;
  const nmap = useMap();
  (0, import_react11.useEffect)(() => {
    if (!autoMount) {
      return;
    }
    if (element.getMap() === nmap) {
      return;
    }
    element.setMap(nmap ? nmap : null);
    return () => {
      element.setMap(null);
    };
  }, [nmap]);
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(EventTargetContext.Provider, {
    value: element,
    children
  });
}

// src/utils/omit-undefined.ts
function omitUndefined(obj) {
  return Object.keys(obj).reduce((acc, key) => {
    if (obj[key] === "undefined") {
      return acc;
    }
    return {
      ...acc,
      [key]: obj[key]
    };
  }, {});
}

// src/overlays/circle.tsx
var import_jsx_runtime7 = require("react/jsx-runtime");
var primitiveKvoKeys = [
  "radius",
  "strokeWeight",
  "strokeOpacity",
  "strokeColor",
  "strokeStyle",
  "strokeLineCap",
  "strokeLineJoin",
  "fillColor",
  "fillOpacity",
  "clickable",
  "visible",
  "zIndex"
];
var kvoKeys2 = [
  ...primitiveKvoKeys,
  "center"
];
var kvoEvents2 = kvoKeys2.map((key) => `${key}_changed`);
var uiEvents2 = [
  "mousedown",
  "mouseup",
  "click",
  "dblclick",
  "rightclick",
  "mouseover",
  "mouseout",
  "mousemove"
];
var events2 = [...uiEvents2, ...kvoEvents2];
var Circle = (0, import_react12.forwardRef)(function Circle2(props, ref) {
  const { center } = props;
  const navermaps = useNavermaps();
  const [circle] = (0, import_react12.useState)(() => new navermaps.Circle(omitUndefined((0, import_lodash4.default)(props, [...kvoKeys2]))));
  (0, import_react12.useImperativeHandle)(ref, () => circle);
  (0, import_react12.useEffect)(() => {
    if (center && !circle.getCenter().equals(center)) {
      circle.setCenter(center);
    }
  }, [center]);
  (0, import_react12.useEffect)(() => {
    circle.setOptions(omitUndefined((0, import_lodash4.default)(props, primitiveKvoKeys)));
  }, primitiveKvoKeys.map((key) => props[key]));
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Overlay, {
    element: circle,
    children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(HandleEvents, {
      events: events2,
      listeners: props
    })
  });
});

// src/overlays/ellipse.tsx
var import_lodash5 = __toESM(require("lodash.pick"));
var import_react13 = require("react");
var import_jsx_runtime8 = require("react/jsx-runtime");
var primitiveKvoKeys2 = [
  "strokeWeight",
  "strokeOpacity",
  "strokeColor",
  "strokeStyle",
  "strokeLineCap",
  "strokeLineJoin",
  "fillColor",
  "fillOpacity",
  "clickable",
  "visible",
  "zIndex"
];
var kvoKeys3 = [
  ...primitiveKvoKeys2,
  "bounds"
];
var kvoEvents3 = kvoKeys3.map((key) => `${key}_changed`);
var uiEvents3 = [
  "mousedown",
  "mouseup",
  "click",
  "dblclick",
  "rightclick",
  "mouseover",
  "mouseout",
  "mousemove"
];
var events3 = [...uiEvents3, ...kvoEvents3];
var Ellipse = (0, import_react13.forwardRef)(function Ellipse2(props, ref) {
  const { bounds } = props;
  const navermaps = useNavermaps();
  const [ellipse] = (0, import_react13.useState)(() => new navermaps.Ellipse(omitUndefined((0, import_lodash5.default)(props, [...kvoKeys3]))));
  (0, import_react13.useImperativeHandle)(ref, () => ellipse);
  (0, import_react13.useEffect)(() => {
    ellipse.setOptions(omitUndefined((0, import_lodash5.default)(props, primitiveKvoKeys2)));
  }, primitiveKvoKeys2.map((key) => props[key]));
  (0, import_react13.useEffect)(() => {
    if (bounds && ellipse.getBounds().equals(bounds)) {
      ellipse.setBounds(bounds);
    }
  }, [bounds]);
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Overlay, {
    element: ellipse,
    children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(HandleEvents, {
      events: events3,
      listeners: props
    })
  });
});

// src/overlays/ground-overlay.tsx
var import_lodash6 = __toESM(require("lodash.pick"));
var import_react14 = require("react");
var import_jsx_runtime9 = require("react/jsx-runtime");
var kvoKeys4 = [
  "clickable",
  "opacity"
];
var kvoEvents4 = kvoKeys4.map((key) => `${key}_changed`);
var uiEvents4 = [
  "mousedown",
  "mouseup",
  "click",
  "dblclick",
  "rightclick",
  "mouseover",
  "mouseout",
  "mousemove"
];
var events4 = [...uiEvents4, ...kvoEvents4];
var GroundOverlay = (0, import_react14.forwardRef)(function GroundOverlay2(props, ref) {
  const options = (0, import_lodash6.default)(props, kvoKeys4);
  const { url, bounds } = props;
  const navermaps = useNavermaps();
  const [groundOverlay, setGroundOverlay] = (0, import_react14.useState)(() => new navermaps.GroundOverlay(url, bounds, options));
  (0, import_react14.useImperativeHandle)(ref, () => groundOverlay, [groundOverlay]);
  (0, import_react14.useEffect)(() => {
    if (groundOverlay.getUrl() !== url || groundOverlay.getBounds().equals(bounds)) {
      setGroundOverlay(new naver.maps.GroundOverlay(url, bounds, options));
    }
  }, [url, bounds]);
  (0, import_react14.useEffect)(() => {
    kvoKeys4.forEach((key) => {
      if (options[key] && groundOverlay.get(key) !== options[key]) {
        groundOverlay.set(key, options[key]);
      }
    });
  }, kvoKeys4.map((key) => options[key]));
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Overlay, {
    element: groundOverlay,
    children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(HandleEvents, {
      events: events4,
      listeners: props
    })
  });
});

// src/overlays/info-window.tsx
var import_lodash7 = __toESM(require("lodash.pick"));
var import_react15 = require("react");
var import_jsx_runtime10 = require("react/jsx-runtime");
var primitiveKvoKeys3 = [
  "content",
  "zIndex",
  "maxWidth",
  "pixelOffset",
  "backgroundColor",
  "borderColor",
  "borderWidth",
  "disableAutoPan",
  "disableAnchor",
  "anchorSkew",
  "anchorSize",
  "anchorColor"
];
var kvoKeys5 = [
  ...primitiveKvoKeys3,
  "position"
];
var kvoEvents5 = kvoKeys5.map((key) => `${key}_changed`);
var uiEvents5 = [
  "mousedown",
  "mouseup",
  "click",
  "dblclick",
  "rightclick",
  "mouseover",
  "mouseout",
  "mousemove"
];
var events5 = [...uiEvents5, ...kvoEvents5];
var InfoWindow = (0, import_react15.forwardRef)(function InfoWindow2(props, ref) {
  const { position } = props;
  const navermaps = useNavermaps();
  const [infoWindow] = (0, import_react15.useState)(() => new navermaps.InfoWindow(omitUndefined((0, import_lodash7.default)(props, [...kvoKeys5]))));
  (0, import_react15.useImperativeHandle)(ref, () => infoWindow);
  (0, import_react15.useEffect)(() => {
    infoWindow.setOptions(omitUndefined((0, import_lodash7.default)(props, primitiveKvoKeys3)));
  }, primitiveKvoKeys3.map((key) => props[key]));
  (0, import_react15.useEffect)(() => {
    if (position && infoWindow.getPosition().equals(position)) {
      infoWindow.setPosition(position);
    }
  }, [position]);
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Overlay, {
    element: infoWindow,
    autoMount: false,
    children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(HandleEvents, {
      events: events5,
      listeners: props
    })
  });
});

// src/overlays/marker.tsx
var import_lodash8 = __toESM(require("lodash.mapkeys"));
var import_lodash9 = __toESM(require("lodash.pick"));
var import_react16 = require("react");
var import_react_use = require("react-use");

// src/utils/get-keys.ts
function getKeys(obj) {
  return Object.keys(obj);
}

// src/utils/uncontrolled.ts
var import_camelcase2 = __toESM(require("camelcase"));
function getUncontrolledKey(key) {
  return (0, import_camelcase2.default)(`default_${key}`);
}
function makeUncontrolledKeyMap(keys) {
  return keys.reduce((acc, key) => ({ ...acc, [getUncontrolledKey(key)]: key }), {});
}

// src/overlays/marker.tsx
var import_jsx_runtime11 = require("react/jsx-runtime");
var primitiveKeys = [
  "animation",
  "icon",
  "shape",
  "title",
  "cursor",
  "clickable",
  "draggable",
  "visible",
  "zIndex"
];
var locationalKeys = ["position"];
var uncontrolledKeyMap = makeUncontrolledKeyMap(locationalKeys);
var kvoKeys6 = [
  ...primitiveKeys,
  ...locationalKeys
];
var kvoEvents6 = kvoKeys6.map((key) => `${key}_changed`);
var uiEvents6 = [
  "mousedown",
  "mouseup",
  "click",
  "dblclick",
  "rightclick",
  "mouseover",
  "mouseout",
  "dragstart",
  "drag",
  "dragend"
];
var events6 = [...uiEvents6, ...kvoEvents6];
function makeInitialOption(props) {
  const uncontrolledProps = (0, import_lodash9.default)(props, getKeys(uncontrolledKeyMap));
  const prefixCleared = (0, import_lodash8.default)(uncontrolledProps, (_, key) => uncontrolledKeyMap[key]);
  const kvoProps = (0, import_lodash9.default)(props, kvoKeys6);
  return omitUndefined({ ...kvoProps, ...prefixCleared });
}
function isLocationalKey(key) {
  return locationalKeys.includes(key);
}
function isEqualKvo(kvo, target) {
  if (kvo === void 0) {
    return false;
  }
  if (kvo === target) {
    return true;
  }
  try {
    return kvo.equals(target);
  } catch {
    return kvo === target;
  }
}
var Marker = (0, import_react16.forwardRef)(function Marker2(props, ref) {
  const navermaps = useNavermaps();
  const [marker] = (0, import_react16.useState)(() => new navermaps.Marker(makeInitialOption(props)));
  (0, import_react16.useImperativeHandle)(ref, () => marker);
  const isFirst = (0, import_react_use.useFirstMountState)();
  const dirtiesRef = (0, import_react16.useRef)({});
  dirtiesRef.current = getDirties();
  function getDirties() {
    if (isFirst) {
      return {};
    }
    return kvoKeys6.reduce((acc, key) => {
      if (props[key] === void 0) {
        return acc;
      }
      if (isLocationalKey(key) && props[getUncontrolledKey(key)] !== void 0) {
        return acc;
      }
      const kvos = marker.getOptions(key);
      if (isEqualKvo(kvos[key], props[key])) {
        return acc;
      }
      return {
        ...acc,
        [key]: props[key]
      };
    }, {});
  }
  function pickDirties(keys) {
    return (0, import_lodash9.default)(dirtiesRef.current, keys);
  }
  (0, import_react16.useLayoutEffect)(() => {
    const { position } = pickDirties(["position"]);
    if (position) {
      marker.setPosition(position);
    }
  }, [dirtiesRef.current["position"]]);
  (0, import_react16.useLayoutEffect)(() => {
    const dirties = pickDirties(primitiveKeys);
    if (Object.values(dirties).length < 1) {
      return;
    }
    marker.setOptions(dirties);
  }, primitiveKeys.map((key) => dirtiesRef.current[key]));
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Overlay, {
    element: marker,
    children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(HandleEvents, {
      events: events6,
      listeners: props
    })
  });
});

// src/overlays/polygon.tsx
var import_lodash10 = __toESM(require("lodash.pick"));
var import_react17 = require("react");
var import_jsx_runtime12 = require("react/jsx-runtime");
var kvoKeys7 = [
  "paths",
  "strokeWeight",
  "strokeOpacity",
  "strokeColor",
  "strokeStyle",
  "strokeLineCap",
  "strokeLineJoin",
  "fillColor",
  "fillOpacity",
  "clickable",
  "visible",
  "zIndex"
];
var kvoEvents7 = kvoKeys7.map((key) => `${key}_changed`);
var uiEvents7 = [
  "mousedown",
  "mouseup",
  "click",
  "dblclick",
  "rightclick",
  "mouseover",
  "mouseout",
  "mousemove"
];
var events7 = [...uiEvents7, ...kvoEvents7];
var Polygon = (0, import_react17.forwardRef)(function Polygon2(props, ref) {
  const options = (0, import_lodash10.default)(props, [...kvoKeys7]);
  const navermaps = useNavermaps();
  const [polygon] = (0, import_react17.useState)(() => new navermaps.Polygon(options));
  (0, import_react17.useImperativeHandle)(ref, () => polygon);
  (0, import_react17.useEffect)(() => {
    polygon.setOptions(omitUndefined(options));
  }, kvoKeys7.map((key) => options[key]));
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Overlay, {
    element: polygon,
    children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(HandleEvents, {
      events: events7,
      listeners: props
    })
  });
});

// src/overlays/polyline.tsx
var import_lodash11 = __toESM(require("lodash.pick"));
var import_react18 = require("react");
var import_jsx_runtime13 = require("react/jsx-runtime");
var kvoKeys8 = [
  "path",
  "strokeWeight",
  "strokeOpacity",
  "strokeColor",
  "strokeStyle",
  "strokeLineCap",
  "strokeLineJoin",
  "clickable",
  "visible",
  "zIndex",
  "startIcon",
  "startIconSize",
  "endIcon",
  "endIconSize"
];
var kvoEvents8 = kvoKeys8.map((key) => `${key}_changed`);
var uiEvents8 = [
  "mousedown",
  "mouseup",
  "click",
  "dblclick",
  "rightclick",
  "mouseover",
  "mouseout",
  "mousemove"
];
var events8 = [...uiEvents8, ...kvoEvents8];
var Polyline = (0, import_react18.forwardRef)(function Polyline2(props, ref) {
  const options = (0, import_lodash11.default)(props, [...kvoKeys8]);
  const navermaps = useNavermaps();
  const [polyline] = (0, import_react18.useState)(() => new navermaps.Polyline(options));
  (0, import_react18.useImperativeHandle)(ref, () => polyline);
  (0, import_react18.useEffect)(() => {
    polyline.setOptions(omitUndefined(options));
  }, kvoKeys8.map((key) => options[key]));
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Overlay, {
    element: polyline,
    children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(HandleEvents, {
      events: events8,
      listeners: props
    })
  });
});

// src/overlays/rectangle.tsx
var import_lodash12 = __toESM(require("lodash.pick"));
var import_react19 = require("react");
var import_jsx_runtime14 = require("react/jsx-runtime");
var optionKeys = [
  "strokeWeight",
  "strokeOpacity",
  "strokeColor",
  "strokeStyle",
  "strokeLineCap",
  "strokeLineJoin",
  "fillColor",
  "fillOpacity"
];
var kvoKeys9 = [
  "bounds",
  "clickable",
  "visible",
  "zIndex"
];
var kvoEvents9 = kvoKeys9.map((key) => `${key}_changed`);
var uiEvents9 = [
  "click",
  "dblclick",
  "mousedown",
  "mouseout",
  "mouseover",
  "mouseup"
];
var events9 = [...uiEvents9, ...kvoEvents9];
var Rectangle = (0, import_react19.forwardRef)(function Rectangle2(props, ref) {
  const options = (0, import_lodash12.default)(props, [...optionKeys, ...kvoKeys9]);
  const navermaps = useNavermaps();
  const [rectangle] = (0, import_react19.useState)(() => new navermaps.Rectangle(options));
  (0, import_react19.useImperativeHandle)(ref, () => rectangle);
  (0, import_react19.useEffect)(() => {
    rectangle.setOptions(omitUndefined(options));
  }, kvoKeys9.map((key) => options[key]));
  return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Overlay, {
    element: rectangle,
    children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(HandleEvents, {
      events: events9,
      listeners: props
    })
  });
});

// src/deprecated.tsx
function RenderAfterNavermapsLoaded() {
  throw new Error("react-naver-maps: v0.1 \uBD80\uD130 <RenderAfterNavermapsLoaded /> \uB294 \uB354\uC774\uC0C1 \uC0AC\uC6A9\uB418\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4. \uB9C8\uC774\uADF8\uB808\uC774\uC158 \uAC00\uC774\uB4DC\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694. https://zeakd.github.io/react-naver-maps/guides/migration-guide-from-0.0");
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Circle,
  Container,
  ContainerContext,
  Ellipse,
  EventTargetContext,
  GroundOverlay,
  InfoWindow,
  Listener,
  LoadNavermapsScript,
  Marker,
  NaverMap,
  NaverMapContext,
  NavermapsProvider,
  Overlay,
  Polygon,
  Polyline,
  Rectangle,
  RenderAfterNavermapsLoaded,
  loadNavermapsScript,
  useContainerContext,
  useEventTarget,
  useListener,
  useMap,
  useNavermaps
});
//# sourceMappingURL=index.js.map